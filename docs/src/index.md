# TikhonovFenichelReductions.jl

A Julia package for computing Tikhonov-Fenichel Parameter Values (TFPVs) for
polynomial ODE systems and their corresponding reductions as described in
[goeke2013a,goeke2014,goeke2015](@cite).

## Overview
The general framework for this package is singular perturbation theory.
More precisely, we consider a system of ODEs in the form 
```math
\begin{split}
\dot{x} = f(x,\pi, \varepsilon) = f^{(0)}(x,\pi) + \varepsilon f^{(1)}(x,\pi), 
\\
x(0)=x_0, x \in U\subseteq\mathbb{R}^n, \pi \in \Pi \subseteq \mathbb{R}^m,
\end{split}
```
where ``f \in \mathbb{R}[x,\pi]`` is polynomial and ``\varepsilon \geq 0`` is a
small parameter. 
The results from [goeke2013a,goeke2014,goeke2015](@cite) allow us to compute a
reduced system for ``\varepsilon \to 0`` in the sense of Tikhonov
[tikhonov1952](@cite) and Fenichel [fenichel1979](@cite) using methods from
commutative algebra and algebraic geometry. 

`TikhonovFenichelReductions.jl` provides procedures for finding all possible
TFPV candidates that yield a reduction in the sense of Tikhonov's theorem (see
[verhulst2007](@cite)) and functions to simplify the computation of the
corresponding reduced systems.
Note that this approach yields all possible timescale separations of _rates_ and
not just _components_ as in the classical approach.

We call a parameter vector, in which some components are set to zero (i.e. the
small parameters), a slow-fast separation of rates. 
Many TFPVs we are interested in are slow-fast separations, but there might
exist TFPVs that are characterized by rational expressions in the original
parameters being small. 
This distinction leads to two different approaches for finding TFPVs.

## Basic Usage 

### Finding TFPV candidates
#### Slow-fast separations
The main functionality is:
~~~
# Setup
problem = ReductionProblem(f, x, p, s, idx_slow_fast)

# Compute TFPV candidates
idx, V, dim_V = tfpv_candidates(problem)
~~~
To initialize the problem, we simply specify the polynomial RHS of the ODE
system ``f`` as a (Julia) function `f(x,p)` and a vector of strings with the
names of the components `x` and parameters `p`, respectively.
The dimension of the reduced system is `s < n`, where `n` is the number of
components.  
`p_sf=p[idx_slow_fast]` are the parameters that should be considered for TFPVs,
i.e. all other parameters are fixed. 

The function `tfpv_candidates` returns all slow-fast separations that are TFPVs.
`V` contains the generators of primary ideals that correspond to the irreducible
components of the affine variety ``\mathcal{V}(f^{(0)}) \subseteq
\mathbb{R}^n``. 
Here, we think of affine variety simply as the zero set of some polynomials (or
ideal, for which it is enough to consider its generators) in the corresponding
affine space.

The functions 
~~~
print_tfpv(prob, idx)
print_varieties(V)
~~~
print out the results in a simple format directly to the REPL. 
You can use the keyword argument `latex=true` to print output as LaTeX source
code. 

To print TFPVs together with the corresponding varieties
``\mathcal{V}(f^{(0)})``, one can also use 
~~~
print_results(problem, idx, V, dim_V)
~~~

#### All TFPVs
To get *all* possible TFPVs, we can consider necessary conditions concerning
``D_1 f``, i.e. the Jacobian of ``f`` w.r.t. the components of the system.
For this, we can compute a Gröbner basis `G` of an ideal in ``\mathbb{R}[\pi]``
(the elimination ideal of the ideal generated by ``f`` and all determinants of
``k\times k`` minors of ``D_1f`` for ``k>s``). 
Then, every TFPV must result in the vanishing of `G`.

### Computing the reduced system
To compute the reduced system, we first need to make the variables available in
the `Main` namespace (parsed to the appropriate types from 
[Oscar.jl](https://www.oscar-system.org/)).
These can be accessed as `problem.x` and `problem.p`. 
Then, we need to construct an instance of type `Reduction`. 
For the first slow-fast separation in `idx`, this can be done with 
~~~
reduction = Reduction(prob, idx[1])
~~~
Looking at `V[1]`, we can see what a possible slow manifold should be, 
since it is contained in one of the irreducible components of the vanishing set
of the polynomials in `V[1]`.
In general, each `V[i][j]` corresponds to the polynomials defining the `j`-th
irreducible component in the affine variety of the `i`-th TFPV candidate.
Similarly, their dimensions are stored in `dim_V[i][j]`.

Before we can compute the reduced system, we can check if the necessary
conditions for its existence are satisfied.
These can be found in [1-3]. 
Essentially, we need to find a manifold of dimension ``s`` contained in
``\mathcal{V}(f^{(0)})``, a non-singular point ``x_0`` on this
manifold and a product decomposition ``f^{(0)} = P\cdot \psi``
that locally satisfies ``\mathcal{V}(f^{(0)}) = \mathcal{V}(\psi)``.

~~~
# define the slow manifold M₀ (M₀ has to have the same format as problem.x)
set_manifold!(reduction, M₀)

# choose a non-singular point x0 on M₀
set_point!(reduction, x0)

# define a product decomposion f⁰ = P⋅Ψ, where Ψ is a r×1 matrix of polynomials
# locally satisfying V(Ψ) = V(f⁰). 
set_decomposition!(reduction, P, Ψ)
# or compute P automatically
set_decomposition!(reduction, Ψ)
~~~

When setting the slow manifold, a check is performed that indicates whether a
generic point on the manifold can be non-singular.
If that is not the case, there exists no reduced system and a warning is thrown.
Otherwise, the generic point is set for the reduction (the method `set_point` is
only useful when a specific point should be chosen).
This is relevant because the reduced system lives on a neighbourhood of ``x_0``
on the slow manifold, which is attractive if all non-zero eigenvalues of ``D_1 f
(x_0, \pi^\star)`` have negative real part.
We can access the Jacobian at ``x_0`` as `reduction.Df_x0` to check the
stability of the reduced system.
However, note that --- as in Tikhonov's theorem --- the convergence can only be
guaranteed on a possibly finite time interval, which we cannot determine a
priori.

If you choose `Psi` as a vector of polynomials in ``\mathbb{R}[x,\pi]``, it can
be possible to automatically compute `P` (which is then a matrix of rational
functions). 
However, as of now this might fail in complicated cases, but it is guaranteed to
work if ``r=n-s=1``.

If all the conditions for the slow manifold, the non-singular point and the
product decomposition are satisfied (indicated by the return value `true` of
each function), we can compute the reduced system with
~~~
g_raw, g = compute_reduction(reduction)
~~~
where `g` corresponds to the RHS of the reduced system on `M₀`.
`g_raw` is the same function, but before substituting the reduced dynamic variables.
If `Oscar` is imported explicitly, you can simplify terms using functions like
`factor` etc.

## Dependencies
This packages only works due to the great [Oscar.jl](https://www.oscar-system.org/) project.

## License
GNU GENERAL PUBLIC LICENSE, Version 3 or later (see LICENSE)
