# TikhonovFenichelReductions.jl

A Julia package for computing Tikhonov-Fenichel Parameter Values (TFPVs) for a
polynomial ODE system and the corresponding reductions (see 
[goeke2013a,goeke2014,goeke2015](@cite) for details).

## Overview
The general framework for this package is singular perturbation theory.
More precisely, we consider a system of ODEs in the form 
```math
\dot{x} = f(x,\pi, \varepsilon), \quad x(0)=x_0, x \in U\subseteq\mathbb{R}^n, \pi \in \Pi \subseteq \mathbb{R}^m,
```
where ``f \in \mathbb{R}[x,\pi]`` is polynomial and ``\varepsilon \geq 0`` is a
small parameter. The results from [goeke2013a,goeke2014,goeke2015](@cite) allow
us to compute a reduced system for ``\varepsilon \to 0`` in the sense of Tikhonov
[tikhonov1952](@cite) and Fenichel [fenichel1979](@cite) using methods from
commutative algebra and algebraic geometry. 

`TikhonovFenichelReductions.jl` implements methods for finding all possible TFPV
candidates,
that yield a reduction in the sense of Tikhonov's theorem (see
[verhulst2007](@cite)).
It also includes functions to simplify the computation of the corresponding
reduced systems.
Note that this approach yields all possible timescale separations of _rates_ and
not just _components_ as in the classical approach.

A slow-fast separation of rates is a parameter vector, in which some components
are set to zero. 
Many TFPVs we are interested in are slow-fast separations, but there might
exist TFPVs that are characterized by rational expressions in the original
parameters being small. 
This distinction leads to two different approaches for finding TFPVs.

## Basic Usage 

### Finding TFPV candidates
The main functionality is:
~~~
# Setup
problem = ReductionProblem(f, x, θ, s, idx_slow_fast)

# Compute TFPV candidates
idx, V, dim_V = tfpv_candidates(problem)
~~~
To initialize a problem, we simply specify the polynomial RHS of the ODE system
``f`` as a (Julia) function `f(x,θ)` and a vector of strings with the names of
the components `x` and parameters `θ`, respectively.
The dimension of the reduced system is `s < n`, where `n` is the number of
components.  
`π=θ[idx_slow_fast]` are the parameters that should be considered for TFPVs,
i.e. all other parameters are in ``\mathcal{O}(1)``. 

The function `tfpv_candidates` returns all slow-fast separations that are TFPVs.
To get *all* possible TFPVs, we can consider necessary conditions concerning
``D_1 f``, i.e. the Jacobian of ``f`` w.r.t. the components of the system.
For this, we can compute a Gröbner basis `G` of an ideal in ``\mathbb{R}[\pi]``
(the elimination ideal of the ideal generated by ``f`` and all determinants of
``k\times k`` minors of ``D_1f`` for any ``k>s``). 
Then, all TFPVs result in the vanishing of `G`.

`V` contains the generators of primary ideals that correspond to the irreducible
components of the affine variety ``\mathcal{V}(f(\cdot,\pi)) \subseteq
\mathbb{R}^n``. 
Here, we think of affine variety simply as the zero set of some polynomials (or
ideal, for which it is enough to consider its generators) in the corresponding
affine space.

The functions 
~~~
print_tfpv(prob, idx)
print_varieties(V)
~~~
print out the results in a simple format directly to the REPL. 
You can use the keyword argument `latex=true` to print output as LaTeX source
code. 

To print TFPVs together with the corresponding varieties
``\mathcal{V}(f^{(0)})``, one can also use 
~~~
print_results(problem, idx, V, dim_V)
~~~

### Computing the reduced system

To compute the reduced system, we first need to make the variables available in
the `Main` namespace (parsed to the appropriate types from 
[Oscar.jl](https://www.oscar-system.org/)).
These can be accessed as `problem.x` and `problem.θ`. 
Then, we need to construct an instance of type `Reduction`. 
For the first slow-fast separation in `idx`, this can be done with 
~~~
reduction = Reduction(prob, idx[1])
~~~
Looking at `V[1]`, we can see what a possible slow manifold should be, 
since it is contained in one of the irreducible components of the vanishing set
of the polynomials in `V[1]`.
In general, each `V[i][j]` corresponds to the polynomials defining the `j`-th
irreducible component in the affine variety of the `i`-th TFPV candidate.
Similarly, their dimensions are stored in `dim_V[i][j]`.

Before we can compute the reduced system, we can check if the necessary
conditions for its existence are satisfied. 
These can be found in [1-3]. 
Essentially, we need to find a manifold of dimension ``s`` contained in
``\mathcal{V}(f(\cdot, \pi^\star))``, a non-singular point ``x_0`` on this
manifold and a product decomposition ``f(\cdot, \pi^\star) = P\cdot \psi``
that locally satisfies ``\mathcal{V}(f(x, \pi^\star)) = \mathcal{V}(\psi)``.

~~~
# define the slow manifold M₀ (M₀ has to have the same format as problem.x)
set_manifold!(reduction, M₀)

# choose a non-singular point x₀ on M₀
set_point!(reduction, x₀)

# define a product decomposion f⁰ = P⋅ψ, where ψ is a r×1 matrix of polynomials
# locally satisfying V(ψ) = V(f⁰). 
set_decomposition!(reduction, P, ψ)
# or compute P automatically
set_decomposition!(reduction, ψ)
~~~

When setting the slow manifold, a check is performed that indicates whether a
generic point on the manifold can be non-singular.
If that is not the case, there exists no reduced system and a warning is thrown.
Otherwise, the generic point is set for the reduction (the method `set_point` is
only useful when a specific point should be chosen).
This is relevant because the reduced system lives on a neighbourhood of ``x_0``
on the slow manifold, which is attractive if all non-zero eigenvalues of ``D_1 f
(x_0, \pi^\star)`` have negative real part.
We can access the Jacobian at ``x_0`` as `reduction.Df_x₀` to check the
stability of the reduced system.
However, note that --- as in Tikhonov's theorem --- the convergence can only be
guaranteed on a possibly finite time interval, which we cannot determine a
priori.

If you choose `ψ` as a vector of polynomials in ``\mathbb{R}[x,\pi]``, it can
be possible to automatically compute `P` (which is then a matrix of rational
functions). 
However, as of now this might fail in complicated cases, but it is guaranteed to
work if ``r=n-s=1``.

If all the conditions for the slow manifold, the non-singular point and the
product decomposition are satisfied (indicated by the return value `true` of
each function), we can compute the reduced system with
~~~
g_raw, g = compute_reduction(reduction)
~~~
where `g` corresponds to the RHS of the reduced system on `M₀`.
`g_raw` is the same function, but before substituting the reduced dynamic variables.

## Dependencies
This packages only works due to the great [Oscar.jl](https://www.oscar-system.org/) project.

## License
GNU GENERAL PUBLIC LICENSE, Version 3 or later (see LICENSE)
