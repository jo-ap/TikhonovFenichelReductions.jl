# TikhonovFenichelReductions.jl

A Julia package for computing Tikhonov-Fenichel Parameter Values (TFPVs) for a
polynomial ODE system and the corresponding reductions (see 
[goeke2013a,goeke2014,goeke2015](@cite) for details).

## Overview
The general framework for this package is singular perturbation theory.
More precisely, we consider a system of ODEs in the form 
```math
\dot{x} = f(x,\pi, \varepsilon), \quad x(0)=x_0, x \in U\subseteq\mathbb{R}^n, \pi \in \Pi \subseteq \mathbb{R}^m,
```
where ``f \in \mathbb{R}[x,\pi]`` is polynomial and ``\varepsilon \geq 0`` is a
small parameter. The results from [goeke2013a,goeke2014,goeke2015](@cite) allow
us to compute a reduced system for ``\varepsilon \to 0`` in the sense of Tikhonov
[tikhonov1952](@cite) and Fenichel [fenichel1979](@cite) using methods from
commutative algebra and algebraic geometry. 

`TikhonovFenichelReductions.jl` implements methods for finding all possible TFPV
candidates, i.e. separations of parameters into small and large (which in turn
correspond to slow-fast separations of processes in the original system),
that yield a reduction in the sense of Tikhonov's theorem (see
[verhulst2007](@cite)).
It also includes functions to simplify the computation of the corresponding
reduced systems.
Note that this approach yields all possible time-scale separations of _rates_ and
not just _components_ as in the classical approach.

## Basic Usage 

### Finding TFPV candidates
The main functionality is:
~~~
# Setup
problem = ReductionProblem(f, x, θ, s, idx_slow_fast)

# Compute TFPV candidates
idx, G, (V, dim_Y) = tfpv_candidates(problem)
~~~
To initialise a problem, we simply specify the polynomial RHS of the ODE system
``f`` as a (Julia) function `f(x,θ)` and a vector of strings with the names of
the components `x` and parameters `θ`, respectively.
The dimension of the reduced system is `s < n`, where `n` is the number of
components.  
`π=θ[idx_slow_fast]` are the parameters that can be considered small, i.e. all
other parameters are fixed and ``\mathcal{O}(1)``. 

Finding TFPV candidates consists of two parts: 
First, we consider necessary conditions concerning ``D_1 f``, i.e. the Jacobian
of ``f`` w.r.t. the components of the system. 
Then, we can check whether the slow manifold can have dimension ``s``.
This is done by the functions `filter_determinants` and `filter_dimension`,
respectively. 
`tfpv_candidates` calls both functions and returns all slow-fast separations
that passed both filters as a vector of boolean indices `idx`, where `0`
corresponds to a small and `1` to a large parameter. 

The additional return values yield more information and can be used later to aid
the computation of corresponding reduced systems.
`G` is a Gröbner basis of an ideal in ``\mathbb{R}[\pi]`` (the elimination
ideal of ``f`` and all determinants of ``k\times k`` minors of ``D_1f`` for any
``k>s``). 
In order for a slow-fast separation to be a TFPV (meaning there exist a
corresponding reduction), all polynomials in `G` need to vanish. 

!!! note "Limitations"
    In simple cases, e.g. when the ideal generated by `G` can be generated by
    monomials, each TFPV is characterised by a subset of the parameters being small
    (`G` vanishes if these are set to zero). 
    These are exactly the TFPV candidates as returned by `tfpv_candidates`. 
    However, in more complicated cases, a TFPV can be characterised by some
    expressions in the original parameters being small. 
    These cannot be found automatically, but they are rational functions whose
    vanishing results in the vanishing of `G`. 
    By rewriting the system appropriately with these expressions as parameters, we
    can again use the methods provided by `TikhonovFenichelReductions.jl`.

`V`contains the generators of primary ideals that correspond to the irreducible
components of the affine variety ``\mathcal{V}(f(\cdot,\pi)) \subseteq
\mathbb{R}^n``. 
Here, we think of affine variety simply as the zero set of some polynomials (or
ideal, for which it is enough to consider its generators) in the corresponding
affine space.
In this case, we take the polynomials in ``f`` as elements of the ring
``\mathbb{R}[x]`` and ``\pi`` as coefficients (in fact, technically we work in
the polynomial ring over the rational function field in ``\pi``:
``\mathbb{R}(\pi)[x]``).

If finding TFPV candidates takes too long, you can disable the computation of
the irreducible components of `V` by setting
`compute_primary_decomposition=false`.
`dim_Y` contains the Krull dimension of each irreducible component of
``\mathcal{V}(f(\cdot,\pi))`` for all slow-fast separations ``\pi`` as defined
in `idx`. 
This is equal to the topological dimension in ``\mathbb{C}[x]``, but can be
larger in ``\mathbb{R}[x]``. 
However, the two notions also coincide over the reals if a component contains a
non-singular point --- which we will require later anyway. 
We can therefore use this information already to discard unwanted cases. 
The default behaviour is to compute a primary decomposition and to check if any
component's dimension is exactly `s`. 
If you want to disable this filter, you can set `exact_dimension=false` (this
only has an effect if `compute_primary_decomposition=true`).

The functions 
~~~
print_tfpv(idx, prob)
print_varieties(V, prob)
~~~
print out the results in a simple format directly to the REPL. 
You can use the keyword argument `latex=true` to print output as LaTeX source
code. 

### Computing the reduced system

To compute the reduced system, we first need to make the variables available in
the `Main` namespace (parsed to the appropriate types from 
[Oscar.jl](https://www.oscar-system.org/)).
These can be accessed as `problem.x` and `problem.θ`. 
Then, we initialise a reduction by constructing an instance of type `Reduction`. 
For the first slow-fast separation in `idx`, this can be done with 
~~~
reduction = Reduction(prob, idx[1])
~~~
Looking at `V[1]`, we can see what a possible slow manifold should be, 
since it is contained in one of the irreducible components of the vanishing set
of the polynomials in `V[1]`
In general, each `V[i][j]` corresponds to the polynomials defining the `j`-th
irreducible component in the affine variety of the `i`-th TFPV candidate.

Before we can compute the reduced system, we can check if the necessary
conditions for its existence are satisfied. 
These can be found in [1-3]. 
Essentially, we need to find a manifold of dimension ``s`` contained in
``\mathcal{V}(f(\cdot, \pi^\star))``, a non-singular point ``x_0`` on this
manifold and a product decomposition ``f(\cdot, \pi^\star) = P\cdot \psi``
that locally satisfies ``\mathcal{V}(f(x, \pi^\star)) = \mathcal{V}(\psi)``.

~~~
# define the slow manifold M₀ (M₀ has to have the same format as problem.x)
set_manifold!(reduction, M₀)

# choose a non-singular point x₀ on M₀
set_point!(reduction, x₀)

# define a product decomposion f⁰ = P⋅ψ, where ψ is a r×1 matrix of polynomials
# locally satisfying V(ψ) = V(f⁰). 
set_decomposition!(reduction, P, ψ)
# or compute P automatically
set_decomposition!(reduction, ψ)
~~~

When setting the slow manifold, a check is performed that indicates whether a
generic point on the manifold can be non-singular.
If that is not the case, there exists no reduced system and a warning is thrown.
Otherwise the generic point is set for the reduction (the method `set_point` is
only useful when a specific point should be chosen).
This is relevant because the reduced system lives on a neighbourhood of ``x_0``
on the slow manifold, which is attractive if all non-zero eigenvalues of ``D_1 f
(x_0, \pi^\star)`` have negative real part.
We can access the Jacobian at ``x_0`` as `reduction.Df_x₀` to check the
stability of the reduced system.
However, note that --- as in Tikhonov's theorem --- the convergence can only be
guaranteed on a possibly finite interval, which we cannot determine a priori.

If you choose `ψ` as a vector of polynomials in ``\mathbb{R}[x,\pi]``, it can
be possible to automatically compute `P` (which is then a matrix of rational
functions). 
However, as of now this might fail in complicated cases, but it is guaranteed to
work if ``r=n-s=1``.

If all the conditions for the slow manifold, the non-singular point and the
product decomposition are satisfied (indicated by the return value `true` of
each function), we can compute the reduced system with
~~~
g_raw, g = compute_reduction(reduction)
~~~
where `g` corresponds to the RHS of the reduced system on `M₀`.
`g_raw` is the same function, but before substituting the reduced dynamic variables.

## Dependencies
This packages only works due to the great [Oscar.jl](https://www.oscar-system.org/) project.

## License
GNU GENERAL PUBLIC LICENSE, Version 3 or later (see LICENSE)
