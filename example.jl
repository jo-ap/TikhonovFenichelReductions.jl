## Demo for TikhonovFenichelReductions.jl 
#
# This example is based on:
# N. Kruff, C. Lax, V. Liebscher, and S. Walcher, ‘The Rosenzweig–MacArthur
# system via reduction of an individual based model’, J. Math. Biol., vol. 78,
# no. 1–2, pp. 413–439, Jan. 2019, doi: 10.1007/s00285-018-1278-y.

## Load packages

using TikhonovFenichelReductions
using Oscar # optional (results in prettier printing and loads Oscar functions to Main namespace)

## Define system

# state variables
x = ["B", "S", "H"]

# parameters
p = ["α", "β", "γ", "δ", "η", "ρ"]

# RHS of ODE system ẋ = f(x, p)
function f(x, p)
  B, S, H = x
  α, β, γ, δ, η, ρ = p
  return [
    ρ*B*(1-B) - α*B*H,
    -η*S + γ*B*H,
    β*S- δ*H + η*S - γ*B*H
  ]
end

# dimension of the reduced system
s = 2

# create Problem
problem = ReductionProblem(f, x, p, s)

# find slow-fast separations that are TFPVs
sf_separations, varieties = tfpvs_and_varieties(problem);

# print slow-fast separations and corresponding slow manifolds with their dimension
print_tfpvs(problem, sf_separations)
print_varieties(varieties)

print_results(problem, sf_separations, varieties)

# find all general TFPVs using necessary conditions on the determinants of D₁f
# G is a Gröbner basis for this, such that every TFPV of dimension s lies in V(G)
G = tfpvs_groebner(problem)

# Typically, the computation of the Gröbner basis in tfpvs_groebner is
# much slower than the computation for slow-fast fast separations in
# tfpvs_and_manifolds, which only computes the irreducible components of V(f(⋅,p_sf))
# and their dimension via a minimal primary computation and the Krull
# dimensions for the corresponding ideals. However, there might exist TFPVs
# which are not slow-fast separations. Here, this is not the case, because G is
# a monomial ideal.

# all TFPVs lie in one of the irreducible components generated by these ideals:
primary_decomposition(ideal(G))

## Make variables and parameters available in Main namespace

B, S, H = system_components(problem)
α, β, γ, δ, η, ρ = system_parameters(problem)

## Compute a reduced system

# The Rosenzweig-MacArthur system corresponds to the TFPV candidate 15 (See section 3.3 in the paper).
# instantiate reduction 
reduction = Reduction(problem, sf_separations[15])

# look at the implicitly given manifold (i.e. variety) that contains the slow manifold
varieties[15][1].gens_R # => M₀ = {(B,S,0) | B,S ∈ ℝ}
varieties[15][1].dim # has dimension 2 
set_manifold!(reduction, [B, S, 0])

# define product decomposion f0 = P⋅Psi (this can be done via the corresponding manifold object)
set_decomposition!(reduction, varieties[15][1])
# it is also possible to set this manually
set_decomposition!(reduction, [H])

# compute the reduced system
compute_reduction!(reduction);

# display reduced system in repl 
print_reduced_system(reduction)
print_reduced_system(reduction; factor=true)

# check if g as the RHS of the reduced system is the same as in the paper 
dBdt = ρ*B*(1-B) - α*(η + β)*B*S//(δ + γ*B)
dSdt = -η*S + γ*(η + β)*B*S//(δ + γ*B)
all(iszero.(reduction.g[reduction.idx_components] .- [dBdt, dSdt])) 

# print to latex 
print_reduced_system(stdout, reduction; latex=true)

# slow manifold is attractive if all non-zero eigenvalues of Df at x0 have negative real part
jacobian_tfpv_at_x0(reduction)

# convenience function to compute reduction directly
Reduction(problem, sf_separations[15], varieties[15][1], parent(B).([B,S,0]))

## Compute multiple reductions at once

# Get all unique slow manifolds of dimension 2 onto which reductions exist
all_varieties = unique_varieties(problem, varieties)

# print generators of affine varieties (i.e. implicit manifolds)
for V in all_varieties 
  println(join(string.(V.groebner_basis), ", "))
end

# we need to work in the rational function field over all vaiables 
F = parent(B//S)

# define explicit description of each unique manifold
M = [
  F.([0,S,H]),
  F.([1,S,H]),
  F.([B,0,H]),
  F.([B,S,0]),
  F.([B,γ//η*B*H,H]),
  F.([B,S,β//δ*S]),
  F.([B,S,ρ//α*(1-B)])
]

# compute all reductions (with a manifold in M)
R, idx = compute_all_reductions(problem, sf_separations, varieties, M; print=true);

# Access the `Reduction` object with the indices as in `manifolds`
# Reduction for `sf_separations[1]` onto `manifolds[1][2]`
R[1][2]

# note that there is a heuristic that can be used to compute all reductions automatically (this may fail for some varieties)
# try to compute the manifolds automatically 
M_auto = [get_explicit_manifold(problem, V) for V in all_varieties]
# check if all manifolds are computed automatically
@assert all([m[2] for m in M_auto])

R, idx = compute_all_reductions(problem, sf_separations, varieties, [M[1] for M in M_auto]; print=true);

